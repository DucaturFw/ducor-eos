#include <eosiolib/eosio.hpp>
#include <eosiolib/singleton.hpp>
#include "oraclized.hpp"

using namespace eosio;

{{~ it.customs :c}}struct {{= c.name}}
{
  {{~ c.fields :f}}{{= f.type }} {{= f.name }};
  {{~}}

  EOSLIB_SERIALIZE({{= c.name }}, {{~ c.fields :f}}({{= f.name }}){{~}})
};
{{~}}
{{~ it.providers :p }}
typedef oraclized<N({{= p.alias }}), {{= p.bestBefore }}, {{= p.updateAfter }}, {{= p.type }}> {{= p.name }}_data;{{~}}
typedef singleton<N(master), account_name> oraclize_master;

class YOUR_CONTRACT_NAME : public eosio::contract
{
private:
{{~ it.providers :p }}
  {{= p.name }}_data {{= p.name }};{{~}}

  account_name master;

public:
  using contract::contract;

  YOUR_CONTRACT_NAME(account_name s) : contract(s){{~ it.providers :p }}, {{= p.name }}(_self, _self){{~}}
  {
    master = oraclize_master(_self, _self).get_or_create(_self, N(undefined));
  }

  void setup(account_name administrator, account_name master, account_name registry)
  {
    require_auth(_self);
    oraclize_master(_self, _self).set(master, _self);
    {{~ it.providers :p}}ask_data(administrator, registry, "{{= p.id }}");
    {{~}}
  }

  void ask_data(account_name administrator, account_name registry, std::string data)
  {
    action(permission_level{_self, N(active)},
           registry, N(ask),
           std::make_tuple(_self, data))
        .send();
  }{{~ it.endpoint :e }}
  
  void push{{= e.suffix }}(account_name oracle, std::string data_id, {{= e.type }} data) 
  {
    require_auth(oracle);
    {{~ it.providers :p }}{{? p.type === e.type }}
    if (strcmp(data_id.c_str(), "{{= p.id }}") == 0) 
    {
      {{= p.name}}.set(data, oracle);
    }{{?}}{{~}}
  }{{~}}
};

EOSIO_ABI(YOUR_CONTRACT_NAME, (setup){{~ it.endpoint : e }}(push{{= e.suffix }}){{~}})